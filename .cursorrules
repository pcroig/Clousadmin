# Reglas de Código - Clousadmin

## TypeScript

### Nunca usar `any`
- ❌ `Record<string, any>`
- ✅ `Record<string, unknown>`
- ✅ Definir interfaces específicas cuando sea posible

### JSON responses
```typescript
// ❌ INCORRECTO
const data = await res.json() as Record<string, any>;

// ✅ CORRECTO
const data = await res.json() as Record<string, unknown>;

// ✅ MEJOR
interface ApiResponse {
  success: boolean;
  data: MyType[];
}
const data = await res.json() as ApiResponse;
```

### Imports
- Mantener orden alfabético (eslint --fix lo hace automáticamente)
- Eliminar imports no usados
- Usar prefix `_` para variables no usadas: `const _unused = value;`

## Workflows (CI/CD)

### Antes de hacer commit
```bash
# 1. Verificar que el código compila
npm run build

# 2. Verificar linting
npx eslint .

# 3. Ejecutar tests
npm run test
```

### Problemas comunes de workflows

#### Error: "Can't reach database server"
**Causa**: Tests en CI no tienen PostgreSQL configurado
**Solución**: Agregar service de PostgreSQL en workflow
```yaml
services:
  postgres:
    image: postgres:15
    env:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: clousadmin_test
```

#### Error: "Check not found" en CD workflow
**Causa**: CD espera un check con nombre incorrecto
**Solución**: Verificar que el nombre del check coincide con el job en CI
```yaml
# En cd.yml, debe coincidir con el nombre del job en ci.yml
check-name: 'Lint, Test & Build'
```

#### Error: "Property X does not exist on type Y"
**Causa**: Schema de validación no coincide con el código
**Solución**:
1. Verificar `lib/validaciones/schemas.ts`
2. Eliminar campos que no existen en el schema
3. Agregar campos al schema si son necesarios

## Componentes React

### forwardRef con props vacíos
```typescript
// ❌ INCORRECTO
type Props = Record<string, never>;

// ✅ CORRECTO
// eslint-disable-next-line @typescript-eslint/no-empty-object-type
interface Props {}
```

### useEffect sin dependencias innecesarias
- Incluir todas las dependencias que usa el efecto
- Si una función no cambia, usar `useCallback`

## Prisma

### Siempre regenerar después de cambios
```bash
# Después de cambiar schema.prisma:
npx prisma generate
npx prisma migrate dev --name descripcion_cambio
```

## Git

### Commits
- Seguir conventional commits: `fix:`, `feat:`, `style:`, `refactor:`
- Incluir firma de Claude Code al final del mensaje
- Agregar `Co-Authored-By: Claude <noreply@anthropic.com>`

### No commitear
- Archivos con secrets (.env, credentials.json)
- node_modules/
- .next/
- Backups (.env.backup.*)

## Documentación

### Mantener documentación actualizada
- **Preferir actualizar documentación existente** cuando ya existe documentación sobre el tema
- Si no existe documentación previa, crear nueva documentación de forma concisa
- Si no existe la sección, crearla de forma concisa
- **Objetivo**: Mantener la documentación actualizada y bien organizada a medida que se hacen cambios
- Buscar documentación existente en `docs/` antes de crear nueva
- Actualizar índices y referencias cuando se modifique documentación

## Arquitectura y Escalabilidad

### Modelos de datos (Prisma)
- **Siempre usar índices** para campos que se usan en WHERE/ORDER BY frecuentemente
- **Normalizar relaciones** evitando duplicación de datos
- **Usar enums de Prisma** en lugar de strings literales para estados
- **Documentar relaciones** con comentarios en schema.prisma

```prisma
// ✅ CORRECTO
model Empleado {
  id        String   @id @default(cuid())
  email     String   @unique
  empresaId String
  empresa   Empresa  @relation(fields: [empresaId], references: [id])

  @@index([empresaId]) // Índice para consultas frecuentes
  @@index([email])
}

enum EstadoSolicitud {
  PENDING
  APPROVED
  REJECTED
}
```

### APIs y lógica de negocio
- **Validar SIEMPRE** con schemas de Zod en `lib/validaciones/schemas.ts`
- **Usar transacciones** para operaciones que afectan múltiples tablas
- **Extraer lógica compleja** a funciones en `lib/` en lugar de en API routes
- **Cachear** consultas costosas con Redis cuando sea posible

```typescript
// ❌ INCORRECTO - Lógica en API route
export async function POST(req: Request) {
  const data = await req.json();
  // 50 líneas de lógica aquí...
}

// ✅ CORRECTO - Lógica extraída
export async function POST(req: Request) {
  const validated = await validateRequest(req, mySchema);
  const result = await createResource(validated.data);
  return successResponse(result);
}
```

### Performance
- **Lazy load** componentes pesados con `dynamic` de Next.js
- **Usar React.memo** solo cuando sea necesario (medir primero)
- **Optimizar queries** con `select` para traer solo campos necesarios
- **Paginar resultados** en listas grandes (usar cursor-based pagination)

```typescript
// ✅ Traer solo lo necesario
const empleados = await prisma.empleado.findMany({
  select: {
    id: true,
    nombre: true,
    apellidos: true,
    // No traer campos grandes como documentos, avatares, etc.
  },
  take: 20, // Paginar
  skip: page * 20,
});
```

### Código limpio
- **Funciones pequeñas**: máximo 50 líneas, una responsabilidad
- **Nombres descriptivos**: `getUsersByDepartment` > `getData`
- **Early returns**: evitar anidación excesiva
- **Extraer constantes**: evitar números/strings mágicos

```typescript
// ❌ INCORRECTO
function process(data: any) {
  if (data) {
    if (data.status === "active") {
      if (data.role === "admin") {
        // hacer algo
      }
    }
  }
}

// ✅ CORRECTO
const ACTIVE_STATUS = "active" as const;
const ADMIN_ROLE = "admin" as const;

function processActiveAdmin(user: User) {
  if (!user) return;
  if (user.status !== ACTIVE_STATUS) return;
  if (user.role !== ADMIN_ROLE) return;

  // hacer algo
}
```

## Errores a evitar

### 1. Usar campos que no existen en schemas
Siempre verificar `lib/validaciones/schemas.ts` antes de usar campos

### 2. No importar `useEffect` cuando se usa
El auto-import puede fallar, verificar imports manualmente

### 3. No configurar BD en tests
Los tests unitarios necesitan PostgreSQL o mocks apropiados

### 4. Cambiar tipos de Record sin actualizar todos los usos
Si cambias un tipo, buscar todos los usos con grep:
```bash
grep -r "Record<string, any>" .
```

### 5. No usar transacciones para operaciones relacionadas
Si una operación falla, todas deben revertirse

### 6. Queries N+1
Usar `include` o `select` de Prisma en lugar de queries anidadas

### 7. No validar datos del usuario
Siempre validar con Zod antes de usar datos de formularios/APIs
